"""
Drudge for reduced BCS Hamiltonian.
"""

import functools, re, warnings

from sympy import Integer, Symbol, IndexedBase, srepr

from drudge.drudge import Tensor
from drudge.fock import PartHoleDrudge, SpinOneHalfPartHoleDrudge
from drudge.su2 import SU2LatticeDrudge
from drudge.term import Vec, Range, Term


class ReducedBCSDrudge(SU2LatticeDrudge):
    r"""Drudge for reduced BCS (pairing) Hamiltonian.

    The reduced BCS drudge contains utilities for solving problems around the
    reduced BCS Hamiltonian, or pairing Hamiltonian.  In this problem, we have
    an :math:`\mathfrak{su}(2)`-like algebra generated by subscriptable
    generators :math:`N`, :math:`P`, and :math:`P^\dag`, which satisfies the
    commutations rules

    .. math::

        [N_p, P_q^\dag] & = 2 \delta_{pq} P_q^\dag \\
        [N_p, P_q] &= -2 \delta_{pq} P_q \\
        [P_p, P_q^\dag] &= \delta_{pq} \left( 1 - N_p \right) \\

    where the symbols :math:`p` and :math:`q` can be over two disjoint ranges,
    the particle range and the hole range.  The usage of these two ranges, as
    well as their default symbols, are exactly the same as those in the
    :py:class:`PartHoleDrudge`.

    In addition to the commutation rules, this drudge also has a Hamiltonian
    stored as ``ham`` attribute, which reads

    .. math::

        \epsilon_p N_p + G_{p, q} P^\dag_p P_q

    where :math:`p` and :math:`q` are summed over the two ranges.

    """

    DEFAULT_CARTAN = Vec('N')
    DEFAULT_RAISE = Vec(r'P^\dagger')
    DEFAULT_LOWER = Vec('P')

    def __init__(
            self, ctx,
            part_range=Range('V', 0, Symbol('nv')),
            part_dumms=PartHoleDrudge.DEFAULT_PART_DUMMS,
            hole_range=Range('O', 0, Symbol('no')),
            hole_dumms=PartHoleDrudge.DEFAULT_HOLE_DUMMS,
            all_orb_range=Range('A', 0, Symbol('na')),
            all_orb_dumms=PartHoleDrudge.DEFAULT_ORB_DUMMS,
            energies=IndexedBase('epsilon'), interact=IndexedBase('G'),
            cartan=DEFAULT_CARTAN, raise_=DEFAULT_RAISE, lower=DEFAULT_LOWER,
            root=Integer(2), norm=Integer(1), shift=Integer(-1), specials=None,
            **kwargs
    ):
        """Initialize the drudge object."""

        # Initialize the base su2 problem.
        super().__init__(
            ctx, cartan=cartan, raise_=raise_, lower=lower, root=root,
            norm=norm, shift=shift, specials=specials, **kwargs
        )

        # Set the range and dummies.
        self.part_range = part_range
        self.hole_range = hole_range
        self.all_orb_range = all_orb_range
        self.set_dumms(part_range, part_dumms)
        self.set_dumms(hole_range, hole_dumms)
        self.raise_ = raise_
        self.cartan = cartan
        self.lower = lower
        self.shift = shift

        #------------------------------------------------------------------------#
        #------GH tweak here to deal with all-orbital-range separately-----------#
        #------NOTE that this renders the breaking of an arbitrary dummy---------#
        #------     into a occ and virtual useless ------------------------------#
        self.all_orb_dumms = tuple(all_orb_dumms)
        self.set_name(*self.all_orb_dumms)
        self.set_dumms(all_orb_range, self.all_orb_dumms)
        self.add_resolver_for_dumms()

        #------ GH commented the next 3 lines
        # self.add_resolver({
        #     i: (self.part_range, self.hole_range) for i in all_orb_dumms
        # })

        #--------------------GH tweak ends here----------------------------------#

        # Make additional name definition for the operators.
        self.set_name(cartan, lower, Pdag=raise_)

        # Create the underlying particle-hole drudge with spin.  Note that this
        # drudge is only use internally for VEV evaluation.
        ph_dr = SpinOneHalfPartHoleDrudge(
            ctx, part_orb=(part_range, part_dumms),
            hole_orb=(hole_range, hole_dumms)
        )
        self._ph_dr = ph_dr

        # Translation from su2 generator to the actual fermion operators.
        cr = ph_dr.cr
        an = ph_dr.an
        up, down = ph_dr.spin_vals

        gen_idx, gen_idx2 = self.all_orb_dumms[:2]
        cartan_def = self.define(
            cartan, gen_idx,
            cr[gen_idx, up] * an[gen_idx, up] +
            cr[gen_idx, down] * an[gen_idx, down]
        )
        raise_def = self.define(
            raise_, gen_idx, cr[gen_idx, up] * cr[gen_idx, down]
        )
        lower_def = self.define(
            lower, gen_idx, an[gen_idx, down] * an[gen_idx, up]
        )
        self._defs = [
            cartan_def, raise_def, lower_def
        ]

        # Define the Hamiltonian.
        ham = self.einst(
            energies[gen_idx] * cartan[gen_idx] +
            interact[gen_idx, gen_idx2] * raise_[gen_idx] * lower[gen_idx2]
        )
        self.ham = ham.simplify()

        # Set additional tensor methods.
        self.set_tensor_method('eval_vev', self.eval_vev)


    #
    # Additional customization of the simplification
    #

    def normal_order(self, terms, **kwargs):
        """Take the operators into normal order.

        Here, in addition to the common normal-ordering operation, we remove any
        term with a cartan operator followed by an lowering operator with the
        same index, and any term with a raising operator followed by a cartan
        operator with the same index.

        """

        noed = super().normal_order(terms, **kwargs)
        if self.shift == Integer(-1):
            noed = noed.filter(functools.partial(
                _nonzero_by_cartan,
                raise_=self.raise_, cartan=self.cartan, lower=self.lower
            ))
        return noed.filter(_is_not_zero_by_nilp)
        return noed

    #
    # Vacuum expectation value
    #

    def _transl2fermi(self, tensor: Tensor):
        """Translate a tensor object in terms of the fermion operators.

        This is an internally utility.  The resulted tensor has the internal
        fermion drudge object as its owner.
        """
        return Tensor(
            self._ph_dr,
            tensor.subst_all(self._defs).terms
        )

    def eval_vev(self, tensor: Tensor):
        r"""Evaluate the vacuum expectation value.

        The VEV facility works *as if* we do substitution

        .. math::

            P_p &= c_{p \downarrow} c_{p \uparrow} \\
            P^\dag_p &= c^\dag_{p \uparrow} c^\dag_{p \downarrow} \\
            N_p &= c^\dag_{p \uparrow} c_{p \uparrow}
                + c^\dag_{p \downarrow} c_{p \downarrow} \\

        for :math:`p` in either particle or hole range and evaluate the
        expectation value with respect to the Fermi vacuum.
        """

        transled = self._transl2fermi(tensor)
        res = self._ph_dr.eval_fermi_vev(transled)
        return Tensor(self, res.terms)

    def eval_agp(self, tensor: Tensor, zlist):
        r"""Evaluate the vacuum expectation value.

        The AGP expectation value facility works *as if* we do substitution
        Takes as input the list of z matrices

        .. math::

            \langle P^\dag_p P_q \rangle &= A^{(0)}_{pq} \\
            \langle P^\dag_p N_r P_q \rangle &= A^{(1)}_{pqr} \\
            \langle P^\dag_p P^\dag_q P_rP_s\rangle &= A^{(0)}_{pqrs} \\

        """

        num_ = self.cartan
        pdag_ = self.raise_
        p_ = self.lower

        def get_vev_of_term(term):
            """Return the vev mapping of the term"""
            vecs = term.vecs
            t_amp = term.amp
            pdag_cnt = 0
            p_cnt = 0
            n_cnt = 0

            pdag_indlist = []
            p_indlist = []
            n_indlist = []

            if len(vecs)==0:
                return [Term(sums=term.sums,amp=t_amp*zlist[0][0],vecs=vecs)]

            # Classify the indices into pdag, n, and p indicies
            for i in vecs:
                if i.base == pdag_:
                    pdag_indlist.extend(list(i.indices))
                elif i.base == p_:
                    p_indlist.extend(list(i.indices))
                elif i.base == num_:
                    n_indlist.extend(list(i.indices))
                else:
                    return []

            # Count the number of indices
            pdag_cnt = len(pdag_indlist)
            p_cnt = len(p_indlist)

            # First, we extract only the unique N indices
            unique_n_indlist = list(set(n_indlist))
            n_cnt = len(unique_n_indlist)

            # Introduce appropriate power of 2 in amplitude to include the effect
            #   of unique indices only  being considered in N
            ldiff = len(n_indlist) - len(unique_n_indlist)
            t_amp *= 2**(ldiff)

            if pdag_cnt != p_cnt:
                # The expression must have equal number of Pdag's and P_'s
                return []
            elif len(pdag_indlist) != len(set(pdag_indlist)):
                return []
            elif len(p_indlist) != len(set(p_indlist)):
                return []
            else:
                # Combining all the indices
                indcs = pdag_indlist
                indcs.extend(unique_n_indlist)
                indcs.extend(p_indlist)

                # Counting the different number of indices in order
                # to select the right symbol 'asymb'
                idx1 = int(n_cnt)
                idx_ppdag = len(indcs) - n_cnt
                idx2 = int( (idx_ppdag / 2) )

                asymb = zlist[idx1][idx2]
                t_amp = t_amp*asymb[indcs]

            return [Term(sums=term.sums,amp=t_amp,vecs=())]

        return tensor.bind(get_vev_of_term)

def _nonzero_by_cartan(term: Term, raise_, cartan, lower):
    """If the term is zero because of the cartan in it."""

    raise_indices = set()
    cartan_indices = set()

    for vec in term.vecs:
        base = vec.base
        indices = vec.indices

        if base == raise_:
            raise_indices.add(indices)
        elif base == cartan:
            if indices in raise_indices:
                return False
            cartan_indices.add(indices)
        elif base == lower:
            if indices in cartan_indices:
                return False

        continue

    return True

def _is_not_zero_by_nilp(term: Term):
    """Test if a term is not zero by nilpotency of the operators.
    """
    cartan = ReducedBCSDrudge.DEFAULT_CARTAN
    raise_ = ReducedBCSDrudge.DEFAULT_RAISE
    lower = ReducedBCSDrudge.DEFAULT_LOWER

    vecs = term.vecs

    pdag_indlist = []
    p_indlist = []
    n_indlist = []

    for i in vecs:
        if i.base == raise_:
            pdag_indlist.extend(list(i.indices))
        elif i.base == lower:
            p_indlist.extend(list(i.indices))
        elif i.base == cartan:
            n_indlist.extend(list(i.indices))
        else:
            raise ValueError('Invalid vector type')
    
    if len(pdag_indlist) != len(set(pdag_indlist)):
        return []
    elif len(p_indlist) != len(set(p_indlist)):
        return []
    else:
        return term
